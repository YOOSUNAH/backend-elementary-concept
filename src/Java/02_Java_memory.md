# Java

---
### 자바의 메모리 영역
* 일반적으로 프로그램은 "코드를 실행하는 영역"과 "데이터를 저장하는 영역"으로 구분하여 메모리를 사용한다
* (JVM의) **데이터 저장 영역은 다시 STATIC , STACK, HEAP 영역으로 분류된다.**
  
* **STATIC 영역**
  - **클래스들의 놀이터** (클래스에 대한 메타정보 저장 영역)
  - Java 파일은 크게 필드(field), 생성자(constructor), 메서드(method)로 구성되어 있고, Static영역에서는 그 중 필드 부분에서 선언된 `전역 변수`와`정적멤버변수(static이 붙은 자료형)`의 데이터를 저장한다.
  - JVM이 동작해서 클래스가 로딩될 때 생성되어, 프로그램의 시작부터 종료될 때까지 메모리에 남아있다.
  - **JVM이 읽어들인 클래스와 인터페이스 대한 런타임 상수 풀, 멤버 변수(필드), 클래스 변수(static 변수), 상수(final), 생성자(constructor)와 메소드(method) 등 을 저장하는 공간.**
- **STACK 영역**
  - **메서드들의 놀이터**
  - 메소드 내에서 정의하는 **기본 자료형 데이터에 해당되는 지역변수,** 메서드로 넘겨 받은 **매개변수**의 **데이터 값**이 저장되는 공간
  - **메소드가 호출될 때 생성되고 (메모리에 할당되고), 종료되면 메모리에서 사라진다.**
    - 메서드의 끝을 알리는 닫는 중괄호`}` 를 만나면 자동으로 메모리에서 제거된다.
- **HEAP 영역 : 객체들의 놀이터**
  - new를 통해 인스턴스 객체를 생성했을 때, Heap 영역에는 생성된 객체가 올라가고 , Stack영역에는 해당 객체에 대한 주소값(Referecne)이 저장된다.
  - 참조형(reference type)데이터 타입을 갖는 객체(인스턴스), 배열 등이 저장되는 공간이다.
  - **Heap 영역은 Stack영역과 다르게 보관되는 메모리가 호출이 끝나더라도 삭제되지 않고 유지된다. 그러다 어떤 참조변수도 Heap 영역에 있는 인스턴스를 참조하지 않게 된다면, GC(가비지 컬렉터)에 의해 메모리에서 청소된다.**
  - JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 **런타임 시 동적으로 할당하**여 사용하는 영역
  - Stack은 스레드 갯수마다 각각 생성되지만, Heap은 몇개의 스레드가 존재하든 상관없이 하나의 Heap 영역만 존재
---
추가 설명

- **STATIC 영역 = Method영역**
  - **클래스들가 저장되는 공간** = **클래스에 대한 메타정보 저장 영역**
  - 멤버 변수(필드), static 변수(클래스 변수), 생성자(constructor)와 메소드(method),
    JVM이 읽어들인 클래스와 인터페이스 대한 런타임 상수 풀, 상수(final) 등 을 저장하는 공간.
  - **Java 파일은 크게 필드(field), 생성자(constructor), 메서드(method)로 구성되어 있고, Static영역에서는 그 중 필드 부분에서 선언된 `전역 변수`와`정적멤버변수(static이 붙은 자료형)`의 데이터를 저장한다.**
    - 정적멤버변수 = static 변수 + static 메서드
    - 정적멤버변수 = 클래스 멤버
    - static 변수 = 클래스 변수
    - 정적 멤버 : 객체에 소속된 멤버가 아닌 class 에 고정(static)된 멤버. ****
  - **JVM이 동작해서 클래스가 로딩될 때 생성되어, 프로그램의 시작부터 종료될 때까지 메모리에 남아있다.**  (=JVM이 종료될때까지 존재한다)
    - 한번 선언된 전역변수는 언제 어디서든 꺼내 쓸 수있다. 개발시에 편리하지만 메모리가 계속 상주해 있어, 사이트가 느려지고 서버가 다운되는 경우가 발생하기도 하니, 잘 사용해야 함.

- **STACK 영역**
  - 메서드가 저장되는 공간
  - 메소드 내에서 정의하는 **기본 자료형에 해당되는 지역변수의 데이터 값이** 저장되는 공간
    - 지역변수 : 메서드 내에서 혹은 중괄호로 둘러싼 블럭 내에서 선언된 변수
    - 기본 자료형을 생성할 때 저장하는 공간으로, 임시적으로 사용 되는 변수나 정보들이 저장되는 영역이다.
    - 참조자료형은 참조값만 저장한다. 이 참조값은 Heap 영역에 존재하는 인스턴스(객체)를 가리킨다.
  - 메서드로 넘겨 받은 매개변수, 메서드 안의 지역변수가 할당된다.
  - 함수 호출 시 생성되는 지역변수와 매개 변수가 저장되는 영역이다.
  - 스레드 마다 하나의 stack 영역이 할당된다. 각각의 stack 영역은 서로 공유하지 않는다.
    - 매개 변수 : 클래스 내부 함수 안에서 사용하는 변수
      - 멤버 변수 : 클래스 내부의 변수, 클래스의 속성과 특성을 나태난다.
      - 메서드 : 클래스 내부 함수 안에서 사용하는 변수

        ```java
        public class Practice{
            public int flower_num; // 멤버변수
            public String flower_name; //멤버 변수
            
            public void Stock(int num, String name){ // 메서드
                flower_num = num; // 매개 변수
                flower_name = name; // 매개 변수		
        } 
            public void Shoew(){ // 메서드
                System.out.println(flower_name + "의 재고수는" + flower_num);
        }
        
        ```

  - **메소드가 호출될 때 생성되고 (메모리에 할당되고), 종료되면 메모리에서 사라진다.**
    - 메소드가 호출될 때 스택 영역에 스택 프레임이 생기고, 그 안에 메소드를 호출한다.
    - stack frame 이 소멸시 지역변수도 같이 소멸된다.
    - 메서드의 끝을 알리는 닫는 중괄호`}` 를 만나면 자동으로 메모리에서 제거된다.
    - 메서드 호출과 stack 프레임의 라이프사이클

      `main()` 메서드는 프로그램이 실행되는 시작점이다.

      `main()` 메서드가 실행될 때 메모리에서 발생하는 일들

      1. JRE는 먼저 프로그램 안에 `main()` 메서드가 있는지 확인한다.
      2. `main()` 메서드의 존재가 확인되면 JRE는 프로그램 실행을 위해 JVM을 부팅한다.
      3. 부팅된 JVM은 목적파일을 받아 그 목적파일을 실행한다.
        - 목적파일을 실행하기 이전에 JVM은 아래와 같은 전처리 과정을 수행한다.
          1. `java.lang` 패키지를 메모리의 스태틱 영역에 로딩시켜 놓는다.
          2. 개발자가 작성한 모든 클래스와 import 패키지를 스태틱 영역에 가져다 놓는다.
          - 목적 파일 : 소스코드가 컴파일 되어 생성되는 파일.

          자바 프로그래밍에서는 일반적으로 `.java` 파일에 소스코드를 작성하고 자바 컴파일러를 통해 컴파일 된 파일은 `.class` 파일이 된다.

      4. `main()` 메서드가 실행될 때 스택 프레임(stack fram)이 스택 영역에 할당된다.

         = 여는 중괄호 { 를 만날 때마다 스택 프레임이 하나씩 생긴다. (클래스 수준의 중괄호 제외) 이후 닫는 중괄호 } 를 만나면 스택 프레임이 소멸된다.

      5. 메서드의 인자 `args` 를 저장할 변수 공간을 스택프레임의 맨 밑에 확보한다.
      6. `main()` 메서드 안의 명령문을 차례대로 수행한다.
      7. `main()` 메서드는 프로그램의 시작점이자 끝이기도 하기 때문에, `main()` 메서드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다.
  - 컴파일 타임시 할당된다.
  - Stack 영역은 LIFO(Last In First Out)의 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.

      ```java
      public void stackAreaExample() {
          int a = 5;	a = 4;	a = 3;	a = 2;
          System.out.println("a : " + a); // 출력된 값 => a : 2
      ```

- **HEAP 영역**
  - **객체 멤버 변수가 할당된다.**
- JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 **런타임 시 동적으로 할당하**여 사용하는 영역
  - 런타임시 할당된다.
1. 인스턴스를 생성할 때 생성되는 메모리 형식이다. new를 사용하여 객체를 생성하면 저장된다
2. 참조형 자료도 heap 메모리 영역으로 저장된다.
- **new를 통해 인스턴스 객체를 생성했을 때, Heap 영역에는 생성된 객체가 올라가고 , Stack영역에는 해당 객체에 대한 주소값(Referecne)이 저장된다.**
  - `클래스 변수 = new 클래스();`를 통해 생성된 객체(인스턴스)
  - 인스턴스의 실제 데이터 → Heap
  - 실제 데이터의 참조값 → Stack영역의 객체가 가짐.
- **참조형(reference type)데이터 타입을 갖는 객체(인스턴스), 배열 등이 저장되는 공간이다.**
  - 참조형의 데이터 객체에서 실제 데이터들이 담기는 공간이다.
- **Heap 영역은 Stack영역과 다르게 보관되는 메모리가 호출이 끝나더라도 삭제되지 않고 유지된다. 그러다 어떤 참조변수도 Heap 영역에 있는 인스턴스를 참조하지 않게 된다면, GC(가비지 컬렉터)에 의해 메모리에서 청소된다.**
- Stack은 스레드 갯수마다 각각 생성되지만, Heap은 몇개의 스레드가 존재하든 상관없이 하나의 Heap 영역만 존재

```java
public void memoryArea {
int a = 10; //정수 값이 할당될 수 있는 메모리 공간을 a라고 잡아두고,
//그 메모리 영역에 10이라는 값이 들어간다.
//즉 Stack 영역의 메모리에 이름을 a라고 붙여주고 값이 10인 메모리 공간을 만드는 것

    User user = new User();//객체를 생성했다면 user은 Stack 영역에 생성되고, 
// new로 생성된 User 클래스의 인스턴스(실제 데이터)는 Heap 영역에 생성됩니다.
}
```
