# Java

---
### 추상 클래스와 인터페이스, 그들의 차이
**추상클래스:**
- `class` 앞에 `abstract` 키워드를 사용하여 정의하고, 하나 이상의 추상 메서드를 가지는 클래스
- **추상 메서드를 선언하여 상속을 통해서 하위 클래스에서 반드시 구현하도록 강제하는 클래스**
- 상속을 위한 클래스이기 때문에 객체를 만들 수 없다. 단, 상속받은 자식클래스에서는 객체를 생성할 수 있다.
- 추상 클래스 존재 목적 : `extends`키워드를 사용해서 자신의 **기능들을 하위클래스로 확장**시키는 것.

**인터페이스**:

- **클래스에서 특정 기능(메서드)을 구현하도록 강제 할 수 있는 기능**
- **구현을 강제함으로써 구현 객체의 같은 동작을 보장할 수 있다.**
    - 추상클래스도 구현을 강제 시킬 수 있다. 추상메서드를 정의할 수있으니깐, 하지만 같은 동작을 보장하지는 않는다.
- `interface` 키워드를 사용하여 선언하며, 인터페이스는 상수(static final)와 추상 메서드(abstract method) 로 구성되어 있다.
- **인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 기능을 구현하도록 한다.**

**추상 클래스와 인터페이스의 차이:**

- **추상 클래스는 상속하여 공통된 기능을 만들고 확장하기 위함,**
- **인터페이스는 구현하는 객체들이 같은 동작을 보장하기 위함.**
- 추상 클래스는 다중 상속이 불가능하고, 인터페이스는 가능하다.
- 추상클래스는 사용 가능 변수 제한이 없고, 사용 가능 접근 제어자도 제한 없다.(public, private, protected, default)
- 인터페이스는 사용가능 변수 : static final(상수)이고, 사용가능접근제어자는 public이다.
- **추상클래스는 서로 비슷한 기능을 하는 클래스들을 묶을 때사용하며,인터페이스는 서로 다른 기능을 하는 클래스들을 묶을 때 사용합니다.**

--
#### 보충 설명
- **추상클래스**
    - 미완성 설계도. 객체 생성 X, 상속받은 자식 클래스는 객체 생성 O, 단일 상속 가능
    - 형식 : `class` 앞에 `abstract` 키워드를 사용하여 정의
        - 상속 키워드 : `extends`  (부모 -자식 관계를 연상)
        - 추상클래스와 실체클래스는 **상속관계**

            ```java
            public **abstract** class Camera {   
            // abstract을 넣어서 Camera라고 하는 추상 클래스가 만들어짐.  
            }
            ```

    - **하나 이상의 추상 메서드를 가지는 클래스**
        - 추상 메서드를 가지지 않아도 상관없지만, 추상 메서드를 하나라도 가지는 클래스는 반드시 추상 클래스가 되어야 한다.
        - 추상 메서드 : 선언만 있고 구현은 없는 메서드, 상속 시 반드시 재정의 해야 하는 메서드
        - 추상 클래스는 일반 메서드, 필드, 추상 메서드를 함께 가질 수 있다.
    - **추상 메서드를 선언하여 상속을 통해서 자식 클래스에서 반드시 구현하도록 강제하는 클래스**
        - 이러한 특성 탓에 미완성 설계도라고 표현하기도 한다.
        - 구현을 강제하지만, 인터페이스와 달리 같은 동작을 보장하지는 않는다.
            - 추상 클래스는 구현된 메서드를 가질 수 있다. 따라서 추상 클래스는 특정 동작의 일부를 구현할 수 있지만, 모든 동작을 추상 메서드로 만들지 않아도 된다.
            - 즉, 클래스는 이미 구현된 메서드를 상속받아 사용할 수 있기 때문에, 그 메서드를 상속받은 자식 클래스에서 필요에 따라 사용하지 않을 수 있다. 이로 인해 같은 동작을 보장하지 않을 수 있다.

            ```java
            abstract class Animal {
                abstract void makeSound();  
                // 추상 메서드, 동물마다 다양한 소리를 만들어야 함
            
                void eat() {
                    System.out.println("Eating...");  
                // 구현된 메서드, 동물이 먹는 행동
                }
            }
            ```

            ```java
            
            class Dog extends Animal {
                void makeSound() {
                    System.out.println("Bark!");  // 강아지는 짖는 소리를 만듦
                }
            }
            
            class Cat extends Animal {
                void makeSound() {
                    System.out.println("Meow!");  // 고양이는 야옹 소리를 만듦
                }
            }
            ```

    - 추상클래스는 실체성이 없고, 구체적이지 않기 때문에 객체를 생성할 수 없다!
        - 상속을 위한 클래스이기 때문에 따로 인스턴스, 즉 객체를 생성할 수 없다.
        - 자식 클래스에서는 객체를 만들 수 있다.

            ```java
            // 추상클래스를 상속한 자식클래스인 FactoryCam에서는 객체를 만드는데 문제가 없음
            // 자식 클래스에서는 객체를 만들 수 있다.
            		FactoryCam factoryCam = new FactoryCam();
                SpeedCam speedCam = new SpeedCam();
            
                // Camera factoryCam = new FactoryCam(); 이렇게 표기할 수도 있다.
            ```

    - 존재 목적 : 자신의 기능들을 하위 클래스로 확장 시키는 느낌.
    - 추상클래스는 실체 클래스의 **공통적인 부분(변수, 메서드)를 추출해서 선언한 클래스**
        - 중복 멤버 통합

          중복되는 멤버를 통합 해주는 기능은 본래 추상 클래스의 기능 이라기 보단 그냥 클래스의 기능이라고 하는게 옳다.

          다만 같은 추상화 개념인 인터페이스와 차이점을 두기 위해, 상수 밖에 정의 못하는 인터페이스에서는 할 수 없는 기능이 추상 클래스 중복 멤버 통합이라고 보면 된다.


- **추상클래스는 왜 사용하는가?**
    1. **공통된 필드와 메서드를 통일할 목적**
        - 실체 클래스는 추상 클래스의 필드와 메서드명을 변결할수 없다. 무조건 해당 명명으로 구현해야 한다. 따라서 필드와 메서드 이름을 통일하여 유지보수성을 높이고 통일성을 유지할 수 있다.
            - **객체 간의 필드와 메서드의 이름을 통일하여 소스의 가독성을 높이기 위해**
                - 추상 클래스는 상속을 강제한다. 즉 부모 클래스에는 메서드의 시그니처만 정의해놓고 그 메서드의 실제 동작은 메서드를 상속받은 하위 클래스의 책임으로 위임하고 있다.
                    - 메서드의 시그니처 : 메소드의 고유성을 나타내는 요소, 메서드 이름과 매개변수 리스트의 조합
            - **개발의 효율성을 증대시키기 위해**
                - 많은 객체들을 생성할 때 모든 객체들에 공통적인 메서드와 필드들을 추상 클래스로 만들고, 이 추상 클래스를 하위 자식들이 상속받아 필요한 필드와 메서드를 그대로 상속하고 추상 클래스는 자식에서 재정의하는 방식을 통해 **개발의 효율성을 증대시킬 수 있다.**
    2. **실체 클래스 구현 시, 시간 절약**
        - 추상클래스를 상속받으면, 자연스럽게 공통적으로 들어가야 할 필드와 메서가 녹여져있는 필드와 메서드가 오버라이딩 된다. 즉, 강제로 주어지는 필드와 메서드를 가지고 나만의 스타일대로 **구현만 하면 된다**. 설계시간이 절약된다. **구현하는데만 집중할 수 있다.**
    3. **규격에 맞는 실체 클래스 구현**
        - 결국 규격 안에서 구현하는 것을 허락한다는 것이지 , 규격도 없이 아무렇게나 구현을 해서는 안된다. 모두가 약속한 필드와 메서드 그리고 설계 규칙에 녹아져 있는 규격에 맞는 클래스를 구현해야 한다. 추상클래스의 기능이 등장한다. 추상클래스를 상속받은 실체 클래스들은 반드시 추상메서드를 재정의(오버라이딩)해서 실행 내용을 작성해야 한다.
        - 소스 수정 시 다른 소스의 영향도를 적게 가져가면서 변화에는 유연하게 만들기 위해 추상클래스를 사용하기도 한다. 규격에 맞게 소스가 구현되어 있기 때문에 해당 규격에 대한 구현부만 수정하면 손 쉽게 수정이 가능하기 때문이다.
- **인터페이스**
    - 객체 생성 X, 상속받은 자식 클래스는 객체 생성 O, 다중 상속 가능
    - 형식 : `interface` 키워드를 사용하여 정의
        - 보통 xxxable 이런 형식으로 인터페이스 네이밍 규칙을 따름
        - 상속 키워드 : `implement`  (클래스를 확장시켜 다양하게 이용하는데 중점)
    - `interface` 키워드를 사용하여 선언하며, 인터페이스는 상수`static final`와 추상 메서드`abstract method` 로 구성되어 있다.
        - JAVA8부터 디폴트 메소드, 정적 메소드가 추가
    - **클래스에서 특정 기능(메소드)을 구현하도록 강제 할 수 있는 기능, 구현을 강제함으로써 구현 객체의 같은 동작을 보장할 수 있다.**
        - 인터페이스란? 극단적으로 동일한 목적 하에 동일한 기능을 보장하기 위함!
        - 어떻게? 자바의 다형성을 이용하여 개발코드 수정을 줄이고 유지보수성을 높인다!
    - **인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 기능을 구현하도록 한다.**
        - (같은 동작 보장)
            - 각 클래스는 `draw()` 메서드를 자신의 목적에 맞게 구현한다.
        - (각 클래스의 목적에 맞게 기능을 구현)
            - Circle 클래스: 원을 그리는 동작을 `draw()` 메서드로 구현했습니다.
            - Square 클래스: 정사각형을 그리는 동작을 `draw()` 메서드로 구현했습니다.

        ```java
        interface Shape {
            void draw();
        }
        ```

        ```java
        class Circle implements Shape {
            public void draw() {
                System.out.println("Circle drawing...");
            }
        }
        
        class Square implements Shape {
            public void draw() {
                System.out.println("Square drawing...");
            }
        }
        ```

    - 인터페이스는 부모 자식 관계인 상속에 얽매이지 않고, 공통 기능이 필요할 때마다 추상 메서드를 정의해놓고 구현`implement`하는 식으로 추상클래스보다 자유롭게 붙였다 땠다 사용
    - 인터페이스는 다중 상속이 가능하며, 클래스가 여러 인터페이스를 구현할 수 있다.
        - 주로 클래스가 어떤 동작을 수행할 수 있는 능력을 정의하기 위해 사용된다.

    ```java
    접근제어자 interface 인터페이스이름 {
    
        public static final 타입 상수이름 = 값;
    
        public abstract 메소드이름(매개변수목록);
    }
    ```

    ```java
    class 클래스이름 implements 인터페이스이름 { ... }
    ```

    - 인터페이스는 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면이라고 한다.
      즉, 사용자가 기기를 쉽게 동작시키는데 도움을 주는 상호작용 시스템을 의미한다.
      이러한 정의를 자바 프로그래밍에 접목해보면, 객체의 인스턴스 메소드를 이용하는 사용자 입장에서 '그 객체의 내부 구현이 어떻든 깊이 학습할 필요없이 원하는 메소드만 호출하고 결과 값을 제대로 받게 해주는 간편한 상호작용 기능이다'
- 인터페이스 특징 , 사용하는 이유
    - **다중 상속**이 가능하다.
        - 부모가 추상 클래스인 경우와 달리 부모가 인터페이스인 경우, 자식 클래스는 인터페이스를 여러개 상속 받을 수 있다.

        ```java
        public class 클래스명 implements 인터페이스1, 인터페이스2, ..
        ```

    - 기능(메서드)의 구현을 강제함으로써, 클래스의 설계 또는 **표준화를** 유도할 수 있다.
        - 대규모 프로젝트 개발 시 일관되고 정형화된 개발을 위한 **표준화가** 가능.
    - 클래스와 클래스 간의 관계를 인터페이스로 연결하면, 클래스마다 **독립적인 프로그래밍**이 가능
    - 형제관계를 맺어준다.
        - 인터페이스는 다중 상속에 대해 제약을 받지 않기 대문에 , 일부만 묶고 싶은 클래스들을 `implements` 키워드로 등록시키면, 각기 다른 부모 클래스를 상속하고 있는 자식 클래스에 인터페이스를 구현(상속)시켜 줌으로써 형제 클래스 끼리 묶는 타입 통합을 이루어 낼 수 있다.
        - 즉, 자유로운 인터페이스 다형성을 통해 코드 중복을 없애고 간편화를 시켜 설계상 이점을 얻을 수 있게 되는 것.
    - 타입 접근 제한
        - 형제 타입 관계를 맺어주면서 동시에 다른 타입의 접근 제한역할도 한다.
    - 메서드 접근 제한
        - 객체에서 사용할 수 있는 메서드를 제한하는 효과도 있다.
    - 의존성을 제거
        - 반환타입이나 매개변수 타입으로 다른 객체와 소통하는 구간에 인터페이스 타입으로 사용함으로써, 객체간 의존성이 줄어들어 자신과 소통하는 객체의 변화에 강한 클래스를 만들 수있게 된다.
    - 개발시간을 단축
        - 인터페이스를 사용하면 클래스의 **선언과 구현을** 분리시킬 수 있기 때문에 실제 구현에 독립적인 프로그램 작성하는 것이 가능하다. = **설계와 구현을 완전히 분리할 수 있다.**
        - 클래스의 작성과 인터페이스의 구현을 동시에 진행할 수 있으므로, 개발 시간을 단축할 수 있다.
        - ex) 클래스와 클래스 간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능하다.
    - 나중에 변경이 용이함.
        - 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음 개발자들에게 인터페이스를 구현하여 프로그램을 짜도록 하면 보다 일관되고 정형화된 프로그램의 개발이 가능하다.
        - interface를 이용하여, 개발 코드를 직접 수정하지 않고도, 사용하고 있는 객체만 변경할 수 있도록 하기 위함이다.
    - 다형성 보장
        - 부모 클래스가 인터페이스이면 자식 클래스가 무조건 구현되어야 한다.
          즉 부모 인터페이스의 모든 메서드들을 자식 클래스에서 반드시 재정의되어야 하기 때문에 다형성이 보장된다.
      
- **추상 클래스와 인터페이스의 차이**
    - `추상 클래스`는 상속하여 공통된 기능을 만들고 확장하기 위함,
    - `인터페이스`는 구현하는 객체들이 같은 동작을 보장하기 위함.
        
      ---

    - `추상 클래스`는 다중 상속이 불가능하고, `인터페이스는` 다중상속이 가능하다.
    - `추상 클래스는` 사용 가능 변수 제한이 없고, 사용 가능 접근 제어자도 제한 없다.(public, private, protected, default)
    - `인터페이스는` 사용가능 변수는 static final(상수)이고, 사용가능접근제어자는 public이다.
        
      ---

    - **`추상 클래스는` 서로 비슷한 기능을 하는 클래스들을 묶을 때 사용한다.**
        - 추상 클래스는 주로 관련 있는 여러 클래스들의 공통된 행동이나 구조를 정의하기 위해 사용
    - **`인터페이스는` 서로 다른 기능을 하는 클래스들을 묶을 때 사용한다.**
        - 인터페이스는 주로 클래스가 어떤 동작을 할 수 있는지를 정의

        ---

    - `추상 클래스는` **일반적인 메서**드와 **추상 메서드**를 포함할 수 있으며, **구현을 갖는 메서드**도 가질 수 있지만**, 상속을 통해 구현해야 하는 추상 메서드를 정의한**다.
    - `인터페이스` 는 **모든 메서드가 추상**이며, **구현을 갖지 않는다**. 구현은 해당 클래스에서 이뤄진다.

  |  | 추상 클래스 | 인터페이스 |
      | --- | --- | --- |
  | 사용 키워드 | abstract | interface |
  | 사용 가능 변수 | 제한 없음 | static final (상수) |
  | 사용 가능 접근 제어자 | 제한 없음 (public, private, protected, default) | public |
  | 사용 가능 메소드 | 제한 없음 | 제한 없음 |
  | 상속 키워드 | extends | implements |
  | 다중상속 가능여부 | 불가능 | 가능 (클래스에 다중 구현, 인터페이스 끼리 다중 상속) |
  | 생성자 | 생성자와 일반변수 모두 가질 수 있다. | 생성자와 일반변수를 가질 수 없다. |
  | 메서드 | 메서드를 부분적으로 구현할 수 있다. | 메서드 선언만 가능하다. |
  | 공통점 | 1. 추상 메소드를 가지고 있어야 한다. </br> 2.인스턴스화 할 수 없다 (new 생성자 사용 X) 인스턴스, 즉 객체를 생성할 수 없다.<br/></br>3. 인터페이스 혹은 추상 클래스를 상속받아 구현한 구현체의 인스턴스를 사용해야 한다.</br></br>4. 인터페이스와 추상클래스를 구현, 상속한 클래스는 추상 메소드를 반드시 구현하여야 한다. | 
 
    - `추상 클래스` 존재 목적 : 추상클래스를 상속 받아서 **기능을 이용하고, 확장**시키는 것.
    - `인터페이스` 존재 목적 : 함수의 구현을 강제하기 위해서. 구현을 강제함으로써 **구현 객체의 같은 동작을 보장하는 것.**
    - `추상 클래스` : 자식 클래스**is kind of**부모 클래스
    - `인터페이스` : 자식 클래스**is able to**부모 인터페이스
- 공통점
    - `추상클래스`와 `인터페이스`는 상속 받는 클래스 혹은 구현하는 인터페이스 안에 있는 **추상메소드를 구현하도록 강제한다.**
    - `인터페이스와 추상 클래스`를 구현, 상속한 클래스는 추상 메소드를 반드시 구현해야 한다.
    - 인스턴스화 할 수 없다. (새로운 생성자 사용 X) = 객체를 생성할 수 없다.
    - `인터페이스 혹은 추상 클래스`를 상속받아 구현한 구현체의 인스턴스를 사용해야 한다.