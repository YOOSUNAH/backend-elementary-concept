   # Java

---
### **제너릭 Generic**

- **데이터의 타입**을 일반화하는 것을 의미한다.(generalize)
- 클래스 내부에서 사용할 **데이터 타입**을 **외부에서 지정하는 기법**을 의미한다.
- 다시 말해, 특정(specific)타입을 미리 정하지 않고, 필요에 의해 지정하는 일반(generic)타입이다.

**제너릭은 왜 사용하는가**

1. 클래스나 메서드 내부에서 사용되는 **객체의 타입 안정성을 높일 수 있기 때문이다.**
2. 클래스 외부에서 타입을 지정해주기 때문에, 따로 **타입을 체크하고 변환해줄 필요가 없기 때문이다.**

**특징**

- 제너릭에 타입으로 **참조형** 만 올수있다. 기본데이터 타입은 올 수 없다.
- 제너릭의 생략이 가능하다.
- 메서드에 적용할 수 있다.

---
추가 설명
**제너릭 Generic**

- 데이터의 타입을 일반화하는 것을 의미한다.(generalize)
    - 타입의 일반화란 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 의미한다.
    - 외부에서 지정한다 : 사용자가 제너릭 클래스의 인스턴스를 생성할 때, 또는 제너릭 메서드를 호출할 때 타입을 정한다는 것을 의미.
- 클래스 내부에서 형식을 지정하지 않고, 사용자에 의해 지정된다.

  특정(specific)타입을 미리 정하지 않고, 필요에 의해 지정하는 일반(generic)타입이다.

- 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법이다.
    - 제네릭 프로그래밍 : **외부 클래스에서 제네릭 클래스를 생성할 때 `<>`괄호 안에 타입을 파라미터로 보내, 제네릭 타입을 지정해주는 것**
    - 인스턴스화 시킬 때 그 클래스가 내부적으로 정해놓은 어떠한 데이터 타입을 인스턴스화 할 때 지정하는 것
- 예시

```java
class Person<T>{
  public T info;
  }
  public class GenericDemo{
  public static void main(Strings[] args){
  Person<String> p1 = new Person<String>();
  Person<StringBuilder> p2 = new Person<StringBuilder>()		
  }
  }
```
ArrayList, LinkedKist
`객체<타입>객체명 = new 객체<타입>();` 로 쓰인다.

이렇게 <>괄호 안에 들어가는 타입을 지정해 준다.
```java
ArrayList<Integer> list1 = new ArrayList<Integer>();
ArrayList<String> list2 = new ArrayList<Integer>();
 
LinkedList<Double> list3 = new LinkedList<Double>():
LinkedList<Character> list4 = new LinkedList<Character>();
```

**특징**
1. **생략 가능 (Optional):**
    - 제너릭 타입은 생략이 가능하며, 필요에 따라 생략하거나 명시적으로 선언할 수 있다. 일반적으로 컴파일러가 타입을 추론하므로 생략이 가능하다.
2. **메서드에 적용 가능:**
    - 제너릭은 클래스뿐만 아니라 메서드에도 적용할 수 있다. 제너릭 메서드는 해당 메서드에서 사용하는 제너릭 타입을 선언하고 활용할 수 있다.
3. **제너릭의 제한 (Bounds):**
    - 제너릭을 사용할 때 특정 타입의 클래스나 인터페이스로 제한하는 것을 의미한다. 
    - 이는 extends 키워드를 사용하여 특정 클래스 또는 인터페이스를 상속받은 클래스로 제한함으로써 타입의 범위를 설정할 수 있다.
   
```java
public class MyClass<T extends SomeClass> {
    // ...
}
//제너릭을 사용하여 특정 클래스의 하위 클래스만을 허용하도록 할 수 있다.
```
4. **참조형(Reference Type)만 허용:**
    - 기본 데이터 타입은 사용할 수 없으며, 제너릭에는 참조형(Reference Type)만이 올 수 있다.
    - 이를 객체로 사용하기 위해 해당 기본 데이터 타입의 Wrapper 클래스를 사용한다.
5. **기본 데이터 타입의 Wrapper 클래스 활용:**
    - 기본 데이터 타입을 **객체로 사용하기 위해서** 해당 기본 데이터 타입에 대한 Wrapper 클래스를 활용한다. Wrapper 클래스는 각 기본 데이터 타입에 대한 래퍼 클래스를 제공하여 제너릭에서 사용할 수 있도록 한다.

**장점**
1. **컴파일 시 타입 안정성:**
    - **제너릭을 사용하면 컴파일 단계에서 잘못된 타입 사용을 방지할 수 있다.** 
    - 이를 통해 런타임에 발생할 수 있는 타입 관련 오류를 사전에 방지할 수 있다.
2. **형 변환 생략:**
    - 제너릭을 사용하면 타입 검사와 형 변환을 컴파일러가 자동으로 처리해준다. 
    - 따라서 개발자가 별도로 타입을 체크하고 변환할 필요가 없어 코드가 간결해지고 관리가 용이해진다.
3. **재사용성:**
    - 제너릭을 사용하면 여러 타입의 객체를 처리하는 클래스나 메서드를 한 번 정의하여 재사용할 수 있다. 
    - 코드의 재사용성이 높아지며, 일관성 있는 코드 작성이 가능하다.
4. **타입 안전성 유지:**
    - 제너릭을 사용하면 타입 안전성을 보장할 수 있으며, 컴파일러가 타입 검사를 수행하여 일관성을 유지한다. 이로 인해 코드의 신뢰성이 향상된다.
5. **IDE 지원과 생산성 향상:**
    - IDE는 제너릭을 활용하여 코드를 작성할 때 타입 힌트를 제공하여 개발자의 생산성을 높여준다. 또한, 코드의 가독성도 향상된다.
    - IDE가 해당 객체의 타입을 알고 있기 때문에 `.`을 입력하여 해당 객체의 속성 힌트를 볼 수 있다.
   
      **제너릭은 왜 사용하는가**
1. **타입 안정성 확보:** 
   - 클래스나 메서드 내부에서 사용되는 **객체의 타입 안정성을 높일 수 있다.**
   - 제너릭을 사용하여 잘못된 타입의 객체를 방지함으로써 프로그램의 타입 안정성을 보장할 수 있다.
2. **코드의 간결성과 가독성:**
    - 제너릭을 활용하면 타입 변환 코드를 줄일 수 있어 코드가 더 간결하고 가독성이 좋아진다.
    - 반환값에 대한 타입 변환 및 타입 검사에 들어가는 **노력을 줄일 수 있다.**
3. **코드 재사용 및 유지 보수 용이성:**
    - 제너릭을 사용하면 다양한 타입에 대해 재사용이 가능하며, 코드의 유지 보수가 편리해진다.
4. **런타임 에러 방지:**
    - 컴파일 시 타입 검사를 통해 런타임에 발생할 수 있는 에러를 사전에 방지할 수 있다.
5. **프로그래머의 실수 방지:**
    - 타입 안정성을 통해 프로그래머가 실수로 잘못된 타입을 사용하는 것을 방지한다.

- 와일드 카드
    - 제너릭의 타입 변수는 단 하나의 타입만 허용한다(불공변 때문에). 이로 인해 발생하는 문제를 해결하기 위해 와일드 카드가 도입되었다.
    - 와일드카드는 모든 타입을 대신하여 다양한 유형의 제너릭 타입을 유연하게 처리할 수 있다.
    - 와일드카드를 사용하면 제너릭 타입의 유연성을 높여, 다양한 상속 구조를 다룰 수 있어, 코드의 재사용성과 유연성을 향상시킬 수 있다.
    - 와일드카드(wildcard)는 제너릭 타입에서 다양한 타입의 상위 타입이나 하위 타입을 나타내기 위해 사용되는 기호로서 "?" 기호로 표시된다.
    - 와일드카드의 중요한 사용법:
        1. **`<?>` (Unbounded Wildcard):**
            - 모든 타입을 나타낸다.
            - 일반적으로 제너릭 메서드나 클래스에서 특정 타입을 알 필요가 없을 때 사용한다.
        2. **`<? extends T>` (Upper Bounded Wildcard):**
            - T와 T의 **하위** 타입만을 나타낸다.
            - 주로 읽기 전용 작업에서 사용된다. 즉, 메서드에서 해당 타입의 값을 반환하거나 읽을 수 있지만 쓸 수는 없다.
        3. **`<? super T>` (Lower Bounded Wildcard):**
            - T와 T의 **상위** 타입만을 나타낸다.
            - 주로 쓰기 작업에서 사용된다. 즉, 메서드에서 해당 타입의 값을 저장할 수 있지만 정확한 타입은 알 수 없다.
