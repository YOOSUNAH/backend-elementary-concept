   # Java

---
### **동일성(identity)과 동등성(equality) **

- **동일성(identity)**

- 두 **객체가** 완전히 같은 것으로, 메모리 내 **주소값이** **같은** 경우를 의미한다.
- 주소 값이 같기 때문에 두 변수가 같은 객체를 가리키는 경우.
- `==` 연산자를 통해 판별한다.

**동등성(equality)**

- **두개의 객체가 같은 정보를** 갖고 있는 경우를 의미한다.
- 동등성은 변수가 참조하고 있는 객체의 **주소가 서로 다르더라도** **내용만 같으면** 두 변수는 동등하다고 이야기 할 수 있다.
- `equals` 연산자를 통해 판별한다.

⇒ 동일하면 동등하지만, 동등하다고 동일한 것은 아니다.

---
추가 설명 </br>

**동일성(identity)**
- **메모리 내 주소값이 같은지 비교한다.**
- `==` 비교를 통해 객체의 메모리 내 주소값이 같은 지 식별한다.**
- 두 객체가 완전히 같은 경우, 완전히 같다는 의미는 메모리에 저장된 객체 중 같은 객체를 가리킨다는 의미로, 변수에 저장된 객체의 주소 같은지를 비교한다.
- 한 사람 당 하나의 값을 갖게 되는, 식별값으로 비교해서 완전히 동일한 것인지 비교하는 것
- 동일하다는 뜻으로 두개의 객체가 완전히 같은 경우를 의미한다. 여기서 완전히 같다는 뜻은 두객체가 사실상 하나의 객체로 봐도 무방하며, **주소 값이 같기 때문에 두 변수가 같은 객체를 가리키게 된다.**

```java
Number number1 = new Number(1);
Number number2 = number1;

System.out.println(number1 == number2);  // true
```

**동등성(equality)**
- **논리적 지위가 동등한지 비교한다.**
- `equals` 메서드와 `hashCode`메서드를 통해 논리적으로 동일한지 확인한다.
    - `euqals` 와 `hashCode`를 오버라이드 해야 한다.
    - equals 연산자는 **재정의하지** 않으면 내부적으로 `==` 연산자와 같은 로직을 수행하므로 차이가 없다. **따라서 equals 연산자는 각 객체의 특성에 맞게 재정의(override)를 해야 동등성의 기능을 수행한다**.
- 동등하다는 의미는 **두개의 객체가 같은 정보를** 가질 때 사용된다.
- 동등성은 변수가 참조하고 있는 객체의 **주소가 서로 다르더라도** **내용만 같으면** 두 변수는 동등하다고  할 수 있다.
  
```java
Number number1 = new Number(1);
Number number2 = new Number(1);
// 변수 number1 과 number2는 각각 다른 메모리 주소를 가리키고 있지만
// 논리적으로 가리키고 있는 별개의 두 객체가 같은 값을 의미하고 있다.
System.out.println(number1.equals(number2));  // true

System.out.println(number1 == number2);  // false
// 같은 객체가 아니기 떄문, 즉 별개의 객체로 식별(identity)되기 때문
```


```java
String str1 = new String("aaa");
String str2 = new String("aaa");
// new 키워드를 통해 다른 String 객체를 메모리에 할당 하였으므로 
// str1과 str1가 가리키는 주소 값은 다르므로 동일하지 않다.

System.out.println(str1.equlas(str2)); // 동등하다.
```
