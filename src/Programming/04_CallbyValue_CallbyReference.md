# Programming

---
### Call by Value, Call by Reference

**메서드를 호출할 때 파라미터를 전달하는 방법**에는 두가지가 있다 .

함수에 정의한 **매개변수의 형태**에 따라 **Call by value** 혹은 **Call by reference**인지 결정된다.

**Call by Value (값에 의한 호출)**

- 메서드를 호출할 때 **값**을 넘겨주기 때문에 Pass by Value라고도 부른다.
- 메서드를 호출하는 호출자( Caller)의 변수와 호출 당하는 수신자(Calee)의 파라미터는 **복사된 서로 다른 변수다.**
  값만을 전달하기 때문에 수신자의 파리미터를 수정해도 호출자의 변수에는 **아무런 영향이 없다**

**Call by Reference (참조에 의한 호출)**

- **참조(주소)**를 직접 전달하며 Pass by Reference라고도 부른다.
- 참조를 직접 넘기기 때문에 호출자의 변수와 수신자의 파라미터는 **완전한 동일한 변수**다.

***Java에서의 파라미터 전달 방법***

- Java는 포인터가 따로 없어 기본적인 매개변수는  Call by Value지만,
  예외적으로 배열과 클래스는 참조변수로 Call by Reference로 작동한다.

---
추가 설명
***Call by Value* (값에 의한 호출)**

- 메서드를 호출할 때 **값**을 넘겨주기 때문에 Pass by Value라고도 부른다. (여기서 값은 주소값이 아닌 그자체로 유의미한 데이터로 생각하면 이해하기 편함)
- 메서드를 호출하는 호출자(Caller)의 변수와 호출 당하는 수신자(Calee)의 파라미터는 **복사된 서로 다른 변수다.**
  값만을 전달하기 때문에 수신자의 파리미터를 수정해도 호출자의 변수에는 **아무런 영향이 없다.**
- 인자로 받은 값을 복사하여 처리를 한다.
- 장점: 복사하여 처리하기 때문에 안전하다. 원래의 값이 보존된다.
- 단점: 복사를 하기 때문에 메모리가 사용량이 늘어난다.

- **JVM 메모리에 변수가 저장되는 위치**
  - Java에서 변수를 선언하면 Stack영역에 할당된다.
  - 원시 타입(Primitive Type)은 Stack 영역에 변수와 함께 저장되며
  - 참조 타입(Reference Type)객체는 Heap 영역에 저장되고 Stack영역에 있는 변수가 객체의 주소값을 갖고 있다.

***Call by Reference* (참조에 의한 호출)**

- **참조(주소)**를 직접 전달하며 Pass By Reference라고도 부른다. 참조를 직접 넘기기 때문에 호출자의 변수와 수신자의 파라미터는 **완전한 동일한 변수**다.
- 참조라는 개념이 포인터이다. 중요한 차이점은. 매개변수가 포인터 변수로 정의되어있다는 것이다.
- Reference자체를 전달하는게  아니라 주소값만 전달해준다.

  (넘겨받은 파라미터는 Stack영역에 생성되고 **넘겨받은 주소값을 똑같이 바라본다.)**


- 다음과 같이 **( )**(괄호) 안에서 자료형 뒤에 *를(애스터리스크) 붙여서 매개변수를 포인터 형태로 만든다.

  `반환값자료형 함수이름(자료형 *매개변수1, 자료형 *매개변수2)`

    ```java
    #include <stdio.h>
    
    void swapNumber(int *first, int *second) // 반환값 없음, int 포인터 매개변수 두 개 지정
    {
        int temp;    // 임시 보관 변수
    
        // 역참조로 값을 가져오고, 값을 저장함
        temp = *first;
        *first = *second;
        *second = temp;
    }
    
    int main()
    {
        int num1 = 10;
        int num2 = 20;
    
        swapNumber(&num1, &num2);        
    		// &를 사용하여 num1과 num2의 메모리 주소를 넣어줌
    
        printf("%d %d\n", num1, num2);   
    		// 20 10: swapNumber에 의해서 num1과 num2의 값이 서로 바뀜
    
        return 0;
    
    실행결과
    20 10
    ```

- 메서드 내에서 **파라미터를 수정하면 그대로 원본 변수에도 반영된다.**
  **인자로 받은 값의 주소를 참조하여 직접 값에 영향을 준다.**
- (변수 자체는 Stack 영역에 생성되지만 실제 객체는 Heap영역에 위치한다.
  그리고 Stack에 있는 **변수가 Heap에 있는 객체를 바라보고 있는 형태**다.)
- 장점: 복사하지 않고 직접 참조를 하기에 빠르다.
- 단점: 직접 참조를 하기에 원래 값이 영향을 받는다.

***Java에서의 파라미터 전달 방법***

- Java는 포인터가 따로 없어 기본적인 매개변수는  Call by Value지만,
- 예외적으로 배열과 클래스는 참조변수로 Call by Reference로 작동한다.